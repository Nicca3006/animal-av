noSuchKeyException=Ressource mit Key "{0}" nicht gefunden
iconNotFound=Icon "{0}" nicht gefunden
algoDescription=Die Skip List ist eine Datenstruktur, die \u00c4hnlichkeiten zu einer Linked List aufweist\nund dadurch schnelles Suchen in einer sortierten Liste erm\u00f6glicht.\n\nSie besteht aus einer Sequenz von Knoten. Jeder dieser Knoten hat eine bestimmte H\u00f6he\nund auf jeder H\u00f6he genau einen Verweis auf einen Nachfolgerknoten. Diese Struktur erm\u00f6glicht\ndas \u00dcberspringen von Knoten und verringert so die Komplexit\u00e4t beim Iterieren \u00fcber die Liste.\n\nGlobal betrachtet besteht die Skip List somit aus mehreren Leveln, welche mit zunehmender\nH\u00f6he sp\u00e4rlicher besetzt sind. Einf\u00fcgen besteht aus zwei Operationen:\n(1) Suchen der Einf\u00fcgeposition und (2) Anpassen der Verweise zwischen den Knoten.\n\nSkip Lists wurden von William Pugh erfunden. Der Pseudocode ist seiner Arbeit entnommen.\nPugh, W. (1990). quot;Skip lists: A probabilistic alternative to balanced treesquot;.\nCommunications of the ACM. 33 (6): 668\u2013676. doi:10.1145/78973.78977.
algoName=Skip List Insertion
name=Skip List Insertion
probabilityAllowedValues=F\u00fcr probability sind nur Werte zwischen 0 und 1 erlaubt.
invalidInput=Ung\u00fcltige Eingabe
headerText=SkipList Insertion
introduction=Einleitung
elementToBeInserted=<-- Einzuf\u00fcgendes Element
insertActionName=Einf\u00fcgen({0})
currentHeight=Aktuelle H\u00f6he: {0}
startAtHeadOnHeight=Starte bei head auf H\u00f6he {0}.
descendLevelInCurrentNode=Steige in der aktuellen Node ein Level ab.
nextElementIs=N\u00e4chstes Element ist {0}.
compare=Vergleiche: {0} < {1}
gotoNextElement=Gehe zum n\u00e4chsten Element. Aktuelles Element ist jetzt {0}.
nextElementIs=N\u00e4chstes Element ist {0}.
nextElementIsNullStop=Da n\u00e4chstes Element null ist, stoppe Traversierung.
stopTraversal={0} >= {1}. Stoppe Traversierung.
savingPointer=Sichere Pointer auf aktuelles Element in Update-Vektor.
updateVectorComplete=Update-Vektor bis zum aktuellen max. Level vollst\u00e4ndig. Starte Einf\u00fcgen des neuen Elements.
checkIfExists=\u00dcberpr\u00fcfung, ob Element bereits in Skip List vorhanden ist.
elementAlreadyExists=Element existiert bereits. \u00dcberschreibe den Wert in der aktuellen Node. Fertig.
determineRandomHeight=Nein. H\u00f6he der neuen Node wird zuf\u00e4llig bestimmt. H\u00f6he: {0}.
checkLevelNewElementHigherThanMax=Pr\u00fcfung ob das Level des neuen Elementes gr\u00f6\u00dfer als die bisherige max. H\u00f6he ist.
yesIncreaseVectorHeight=Ja: Bisherige max. H\u00f6he ist {0}. Update-Vektor wird um {1} vergr\u00f6\u00dfert.
forEveryLevelOfNewElement=F\u00fcr jedes Level des neuen Elementes gr\u00f6\u00dfer als momentanes max. Level wird der Update-Vektor auf den Head gesetzt.
updateMaxLevel=Momentanes max. Level wird aktualisiert.
createNewElement=Erstelle neues Element {0}.
markedPointersNeedUpdating=Markierte Pointer m\u00fcssen aktualisiert werden.
pointerOnLevelCorrected=Pointer auf Level {0} korrigiert.
elementXInsertedSuccess=Das Element {0} wurde erfolgreich vollst\u00e4ndig eingef\u00fcgt.
algoConclusion=Durch ihre besondere Struktur weist die Skip List f\u00fcr Einf\u00fcgeoperationen eine durchschnittliche\nKomplextit\u00e4t von O(log n) auf.\n\nEine weitere Besonderheit ist, dass sie wegen der zuf\u00e4lligen Bestimmung der H\u00f6he von Knoten\neine randomisierte Datenstruktur ist. Das Einf\u00fcgen der selben Elemente f\u00fchrt in verschiedenen\nF\u00e4llen somit zu unterschiedlichen Zust\u00e4nden in der Datenstruktur. Alternativ zu dieser\nvorgestellten Implemetierung ist auch eine Implementierung m\u00f6glich, bei der die H\u00f6hen\nder Knoten nicht zuf\u00e4llig gew\u00e4hlt werden, sondern quot;perfektquot; bestimmt werden,\nsodass eine Komplexit\u00e4t von O(log n) beim Einf\u00fcgen zugesichert werden kann.\n\nDie Skip List ist eine effiziente Datenstruktur f\u00fcr die grundlegenden Operationen\nSuchen, Einf\u00fcgen und L\u00f6schen und bietet damit eine gute Alternative z.B. zu Bin\u00e4rb\u00e4umen.
conclusion=Fazit
