descriptionPart1=The vector clock algorithm assigns each process in a distributed system a vector of logical clocks with as many entries as there are processes in order to find the order of events that happened within these processes.\n\n- Initially, all logical clocks in the clock vectors are set to zero.\n\n- Whenever an event takes place in a process - either an internal event, the sending of a message or the reception of a message - first of all, the process increments its own logical clock in its clock vector by one.\n\n- Whenever a process sends a message to another process, it attaches its current clock vector to the message.\n\n- Whenever a process receives a message, it compares each logical clock of its current clock vector to the corresponding logical clock of the received clock vector and updates each entry in its clock vector with the maximum of both values.\n\nFinally, a timestamp that contains the current clock vector of the process where the event takes place is attached to the event.\n\n\n\n

descriptionPart2=After the events have received timestamps, comparing them allows to find the partial and causal order of the events.\n\nIf an event happened before another event, the following conditions must be fulfilled by the timestamps of the events:\n\n    - All timestamp entries of the event that happened first are less than or equal to the corresponding entries of the timestamp of the other event.\n\n    - There is at least one entry in the timestamp of the event that happened first that is strictly smaller than the corresponding entry in the timestamp of the other event.\n\n-> If these conditions are fulfilled for events A and B, it can be stated that event A happened before event B.\n\n\n\nThe partial order of the events has the properties of antisymmetry and transitivity:\n\n    - Antisymmetry: If event A happened before event B, then event B cannot have happened before event A.\n\n    - Transitivity: If event A happened before event B and event B happened before event C, then event A also happened before event C.\n\nHaving no order between two events implies that these events (could have) happened concurrently and that there is no causal relationship between these events.\n\n\n\n

descriptionPart3=Events primitive:\n\n Each row represents either an internal event or the sending AND receiving of a message.\n\n Columns:\n\n 0: Time when the event happens (as integer)\n\n 1: Name of the process where the event happens\n\n 2: Type of event: I for internal or M for message (in this case, column 1 is the sending process)\n\n 3: if M: Name of the process that receives the message, if I: -\n\n 4: if M: Time when the message is received (has to be greater than column 0), if I: -\n\n 5: check step-by-step which events happened before this event: y(es) or n(o)

descriptionPart4=The event timestamps generated by the vector clock algorithm made it possible to determine the partial and causal order of the events.\nBecause the algorithm uses clock vectors with information of all processes instead of single logical clocks, events in the order are guaranteed to be in a happened-before relationship.\nThis is an improvement to Lamport's timestamps where only timestamps of single logical clocks are used and where a smaller timestamp does not guarantee that an event actually happened before another event.\nHowever, compared to Lamport's timestamps, the vector clock algorithm has a higher communication complexity that increases with the amount of involved processes.

codeExampleInitialization=foreach process of N processes:\n create clock vector with N elements\n set every entry to zero\n\n

codeExampleTimestamps=foreach event:\n if internal event:\n  increment logical clock in clock vector of event process by one\n if message sent:\n  increment logical clock in clock vector of event process by one\n  attach clock vector of event process to message\n if message received:\n  increment logical clock in clock vector of event process by one\n  foreach element in clock vector of event process:\n   update element with maximum of own clock vector and received clock vector

codeExampleComparison=foreach entry:\n if other entry is less than or equal to own entry:\n  continue comparing\n else:\n  stop comparing, no success\nif comparison successful:\n if at least one other entry is less than own entry:\n  other event happened before

slideIntroduction=slideDescriptionEN.txt
slideConclusion=slideConclusionEN.txt

codeInitLine1=foreach process of N processes:
codeInitLine2=create clock vector with N elements
codeInitLine3=set every entry to zero

code1Line1=if internal event:
code1Line2=increase own clock in vector by 1
code1Line3=if message sent:
code1Line4=increase own clock in vector by 1
code1Line5=send copy of own vector
code1Line6=if message received:
code1Line7=increase own clock in vector by 1
code1Line8=foreach element in vector:
code1Line9=update with maximum of own vector and received vector
code1Line10=attach clock vetor to event as timestamp

code2Line1=foreach entry:
code2Line2=if other entry is less than or equal to own entry:
code2Line3=continue comparing
code2Line4=else:
code2Line5=stop comparing, no success
code2Line6=if comparison successful:
code2Line7=if at least one other entry is less than own entry:
code2Line8=other event happened before

### chapter strings ###
introduction=Introduction
initialization=Initialization
initializationComplete=Initialization complete
oneProcessed=processed
allProcessed=All events processed
compareEvents=Compare events
compareWith=compared with
happenedBefore=Events happened before
eventOrder=Event order
conclusion=Conclusion

### labels ###
currentActivityInit=Initialize clock vectors
currentActivity1=Compute event timestamps
currentActivity2=Compare event timestamps
currentActivity3=Causal relationships of events
currentProcessLabel=Current process
currentEventLabel=Current event
otherEventLabel=Other event
foundEventsLabel=Events that happened before
noElement=-

comparisonSuccessful=Comparison successful
strictlySmaller=One entry strictly smaller
true=true
false=false

### exception messages ###
processException=Processes must have different names (check Processes)
eventElementsException=Events primitive rows must have 6 columns
eventTypeException=Event must be of type I or M (check Events column 2)
eventTimeBelowZeroException=Event time must be greater than 0 (check Events column 0)
eventMaxTimeNotAboveZeroException=At least one event must happen after time 0 (check Events columns 0 and 4)
eventProcessException=Event process name must exist in Processes primitive (check Events column 1 and Processes)
eventMessageException=Event message reception time must be greater than message sending time (check Events column 4 > column 0)
eventReceiverException=Event message receiving process name must exist in Processes primitive (check Events column 3 and Processes)

### questions and answers (needs UTF8 encoding) ###
fibWarning=(There is only one correct answer. If [Congratulations, your answer is correct.] is displayed, your answer is wrong.)
evIN=internal event
evMS=message sent event
evMR=message received event
actionIncrement=Increment own entry in clock vector
actionSend=Send copy of own clock vector
actionMax=Take maximum of own and received clock vector per entry
correctAnswer=Correct.
wrongAnswer=Wrong.
qInitRows=How many entries does each clock vector have after initialization?
aInitRows={0} is correct.
qInitValue=What is the value of each clock vector entry after initialization? 
aInitValue=0 is correct.
qEvType1=What type of event is event {0}?
qEvType2=Which steps will be executed for event {0}?
qEvActionSeq1=Which step is executed first?
qEvTimestamp1=What will be the values of the timestamp of event {0}? (Enter the values separated by comma, e.g. 1,2,3)
qEvHappenedBefore1=According to the conditions, did event {0} happen before event {1}?